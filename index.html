<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>HUD Navigator (OSRM)</title>

  <!-- PWA / fullscreen hints -->
  <meta name="theme-color" content="#000000">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="HUD Nav">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root { --bg:#000; --fg:#fff; --muted:#9aa0a6; }

    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overscroll-behavior:none;
      -webkit-tap-highlight-color: transparent;
    }

    .screen{ display:none; height:100dvh; width:100vw; }
    .screen.active{ display:flex; }

    #start{ flex-direction:column; align-items:center; justify-content:center; gap:16px; padding:18px; }
    .bigbtn{
      width:min(520px, 92vw);
      height:min(44dvh, 320px);
      border-radius:22px;
      border:2px solid #2a2a2a;
      background:#080808;
      color:var(--fg);
      font-size:28px;
      font-weight:800;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      user-select:none;
      touch-action: manipulation;
    }

    .row{ width:min(520px, 92vw); display:flex; gap:10px; }
    input[type="text"]{
      flex:1;
      padding:14px 14px;
      border-radius:14px;
      border:1px solid #2a2a2a;
      background:#0b0b0b;
      color:var(--fg);
      font-size:16px;
    }
    button{
      padding:14px 14px;
      border-radius:14px;
      border:1px solid #2a2a2a;
      background:#111;
      color:var(--fg);
      font-size:16px;
      font-weight:700;
      touch-action: manipulation;
    }
    button:active, .bigbtn:active{ transform: scale(0.99); }
    .small{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
      text-align:center;
      width:min(520px, 92vw);
    }

    /* HUD */
    #hud{
      position:relative;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      overflow:hidden;
      background:#000;
    }

    /* Stage wrapper so rotate/mirror applies to HUD + map together */
    #hudStage{
      position:absolute;
      inset:0;
      z-index:1;
    }

    /* inner that we transform */
    #hudStageInner{
      position:absolute;
      left:50%;
      top:50%;
      width:100%;
      height:100%;
      transform: translate(-50%, -50%) rotate(var(--rot, 0deg)) scaleX(var(--mx, 1));
      transform-origin: center;
    }

    /* When quarter-turn: swap width/height to fit */
    #hud.quarterturn #hudStageInner{
      width:100dvh;
      height:100vw;
    }

    /* ----- Map as BACKGROUND layer (always behind HUD content) ----- */
    #mapPane{
      position:absolute;
      inset:0;
      background:#000;
      z-index:0;              /* <- behind */
      display:none;
      overflow:hidden;
    }
    #map{
      width:100%;
      height:100%;
      /* Force black/white even if tiles are colored */
      filter: grayscale(1) contrast(1.25) brightness(0.85);
      transform: translateZ(0);
    }
    /* optional dim overlay so HUD stays readable */
    #mapDim{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.45);
      pointer-events:none;
    }

    /* ----- HUD content layer (always on top) ----- */
    #hudContent{
      position:absolute;
      inset:0;
      z-index:2;              /* <- above map */
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:10px;
      pointer-events:none;    /* tap goes to parent (mirror) */
    }

    #arrowWrap{
      width:min(70vw, 420px);
      height:min(42dvh, 340px);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #meters{
      font-size: clamp(44px, 7vw, 92px);
      font-weight:900;
      letter-spacing:0.5px;
    }
    #status{
      font-size:14px;
      color:var(--muted);
      padding:0 16px;
      text-align:center;
      max-width:min(92vw, 680px);
    }

    /* Top bar above everything */
    #topBar{
      position:absolute;
      top: env(safe-area-inset-top);
      left:0; right:0;
      padding: 10px 12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      z-index:10;
      pointer-events:auto;
    }
    .pill{
      padding:8px 10px;
      border:1px solid #2a2a2a;
      border-radius:999px;
      background:#0b0b0b;
      font-size:13px;
      color:var(--fg);
      user-select:none;
      pointer-events:auto;
    }
    .pill.muted{ color:var(--muted); }
    #mapToggle, #rotToggle{ cursor:pointer; }

    /* Leaflet minimal */
    .leaflet-control-attribution, .leaflet-control-zoom{ display:none !important; }
  </style>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
</head>
<body>

<div id="start" class="screen active">
  <div id="voiceBtn" class="bigbtn">ðŸŽ™ Spreek adres</div>

  <div class="row">
    <input id="addr" type="text" placeholder="â€¦of typ adres (bv. Coolsingel 1 Rotterdam)" autocomplete="off" />
  </div>

  <div class="row">
    <button id="startBtn" style="flex:1">Start navigatie</button>
    <button id="debugBtn">Kaart: aan</button>
  </div>

  <div id="startStatus" class="small">Tip: Sta locatie toe. In HUD: tik = spiegeling.</div>
</div>

<div id="hud" class="screen">
  <div id="topBar">
    <div class="pill" id="gpsPill">GPS: â€¦</div>
    <div class="pill muted" id="rotToggle">â¤¾ 90Â°</div>
    <div class="pill muted" id="mapToggle">ðŸ—º</div>
    <div class="pill muted" id="stopBtn">Stop</div>
  </div>

  <div id="hudStage">
    <div id="hudStageInner">

      <!-- Map background -->
      <div id="mapPane">
        <div id="map"></div>
        <div id="mapDim"></div>
      </div>

      <!-- HUD foreground -->
      <div id="hudContent">
        <div id="arrowWrap"></div>
        <div id="meters">-- m</div>
        <div id="status">Wachtenâ€¦</div>
      </div>

    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(() => {
  // PWA SW
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(() => {});
  }

  // --------------------------
  // Config
  // --------------------------
  const OSRM_BASE = "https://router.project-osrm.org";
  const NOMINATIM = "https://nominatim.openstreetmap.org/search";
  const ARRIVE_RADIUS_M = 80;
  const LOOKAHEAD_STEP_M = 60;
  const HEADING_MIN_SPEED_MPS = 4;
  const UPDATE_UI_MS = 500;

  // Zwart-wit tiles (gratis). Als deze ooit traag is, blijft CSS filter nog steeds B/W afdwingen.
  const BW_TILES = "https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png";

  // --------------------------
  // DOM
  // --------------------------
  const startScreen = document.getElementById("start");
  const hudScreen   = document.getElementById("hud");
  const voiceBtn    = document.getElementById("voiceBtn");
  const startBtn    = document.getElementById("startBtn");
  const debugBtn    = document.getElementById("debugBtn");
  const addrInput   = document.getElementById("addr");
  const startStatus = document.getElementById("startStatus");

  const gpsPill     = document.getElementById("gpsPill");
  const rotToggle   = document.getElementById("rotToggle");
  const mapToggle   = document.getElementById("mapToggle");
  const stopBtn     = document.getElementById("stopBtn");

  const arrowWrap   = document.getElementById("arrowWrap");
  const metersEl    = document.getElementById("meters");
  const statusEl    = document.getElementById("status");
  const mapPane     = document.getElementById("mapPane");

  // --------------------------
  // State
  // --------------------------
  let debugMapEnabled = true;
  let mirrored = false;
  let quarterTurn = false;

  let watchId = null;
  let lastFix = null;
  let headingDeg = null;
  let speedMps = 0;

  let routePts = [];
  let wpIdx = 0;

  // Leaflet
  let map = null, posMarker = null, routeLine = null, wpMarker = null;

  // --------------------------
  // Helpers
  // --------------------------
  function applyStageTransform() {
    hudScreen.style.setProperty("--mx", mirrored ? -1 : 1);
    hudScreen.style.setProperty("--rot", quarterTurn ? "90deg" : "0deg");
    hudScreen.classList.toggle("quarterturn", quarterTurn);

    if (debugMapEnabled && map) {
      setTimeout(() => { try { map.invalidateSize(true); } catch {} }, 80);
    }
  }

  function requestFullscreenBestEffort() {
    const el = document.documentElement;
    const fn = el.requestFullscreen || el.webkitRequestFullscreen;
    if (fn) { try { fn.call(el); } catch {} }
  }

  // --------------------------
  // Math helpers
  // --------------------------
  const R = 6371000;
  const toRad = d => d * Math.PI / 180;
  const toDeg = r => r * 180 / Math.PI;

  function haversineM(a, b) {
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const x = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(x));
  }

  function bearingDeg(a, b) {
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const dLon = toRad(b.lon - a.lon);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    return (toDeg(Math.atan2(y, x)) + 360) % 360;
  }

  function wrap180(d) {
    return ((d + 180) % 360) - 180;
  }

  // --------------------------
  // SVG arrows
  // --------------------------
  function svgArrow(type) {
    const common = `viewBox="0 0 100 100" width="100%" height="100%"`;
    const stroke = `fill="none" stroke="white" stroke-width="10" stroke-linecap="round" stroke-linejoin="round"`;
    const fill = `fill="white"`;
    if (type === "nofix") {
      return `<svg ${common}><circle cx="35" cy="50" r="6" ${fill}/><circle cx="50" cy="50" r="6" ${fill}/><circle cx="65" cy="50" r="6" ${fill}/></svg>`;
    }
    if (type === "uturn") {
      return `<svg ${common}>
        <path d="M70 80 V45 Q70 25 50 25 Q30 25 30 45 V55" ${stroke}/>
        <path d="M30 55 L18 43" ${stroke}/>
        <path d="M30 55 L42 43" ${stroke}/>
      </svg>`;
    }
    const base = `<svg ${common}>
      <path d="M50 85 V20" ${stroke}/>
      <path d="M50 20 L32 38" ${stroke}/>
      <path d="M50 20 L68 38" ${stroke}/>
    </svg>`;
    const rot = {
      up: 0, upright: 45, right: 90, downright: 135,
      downleft: -135, left: -90, upleft: -45
    }[type] ?? 0;
    return `<div style="width:100%;height:100%;transform:rotate(${rot}deg)">${base}</div>`;
  }

  function deltaToArrow(delta) {
    const a = Math.abs(delta);
    if (a < 15) return "up";
    if (a < 35) return delta > 0 ? "upright" : "upleft";
    if (a < 80) return delta > 0 ? "right" : "left";
    if (a < 120) return delta > 0 ? "downright" : "downleft";
    return "uturn";
  }

  // --------------------------
  // Route resampling
  // --------------------------
  function resampleRoute(points, stepM) {
    if (points.length < 2) return points.slice();
    const out = [points[0]];
    let acc = 0;
    for (let i = 1; i < points.length; i++) {
      let p0 = out[out.length - 1];
      let p1 = points[i];
      let seg = haversineM(p0, p1);
      if (seg < 1) continue;

      while (seg >= (stepM - acc)) {
        const t = (stepM - acc) / seg;
        const lat = p0.lat + (p1.lat - p0.lat) * t;
        const lon = p0.lon + (p1.lon - p0.lon) * t;
        const np = {lat, lon};
        out.push(np);
        p0 = np;
        seg = haversineM(p0, p1);
        acc = 0;
      }
      acc += seg;
    }
    const last = points[points.length - 1];
    const end = out[out.length - 1];
    if (haversineM(end, last) > stepM * 0.3) out.push(last);
    return out;
  }

  // --------------------------
  // APIs
  // --------------------------
  async function geocodeAddress(q) {
    const url = `${NOMINATIM}?format=json&limit=1&q=${encodeURIComponent(q)}`;
    const r = await fetch(url, { headers: { "Accept": "application/json" } });
    const data = await r.json();
    if (!data || !data[0]) throw new Error("Adres niet gevonden.");
    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
  }

  async function fetchOsrmRoute(start, end) {
    const url = `${OSRM_BASE}/route/v1/driving/${start.lon},${start.lat};${end.lon},${end.lat}?overview=full&geometries=geojson&steps=false`;
    const r = await fetch(url);
    const data = await r.json();
    if (!data || data.code !== "Ok") throw new Error("OSRM route faalde.");
    const coords = data.routes[0].geometry.coordinates;
    return coords.map(c => ({ lon: c[0], lat: c[1] }));
  }

  // --------------------------
  // GPS
  // --------------------------
  function startWatch() {
    if (!navigator.geolocation) throw new Error("Geolocation niet beschikbaar.");
    const opts = { enableHighAccuracy: true, maximumAge: 500, timeout: 10000 };
    watchId = navigator.geolocation.watchPosition(onPos, onPosErr, opts);
  }

  function stopWatch() {
    if (watchId != null) navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }

  function onPos(pos) {
    const { latitude: lat, longitude: lon, speed } = pos.coords;
    const ts = pos.timestamp || Date.now();
    speedMps = (typeof speed === "number" && !Number.isNaN(speed)) ? speed : 0;

    const cur = { lat, lon, ts };
    gpsPill.textContent = "GPS: ok";
    gpsPill.style.borderColor = "#2a2a2a";

    if (lastFix) {
      const dt = Math.max(0.001, (ts - lastFix.ts) / 1000);
      const dist = haversineM({lat:lastFix.lat, lon:lastFix.lon}, {lat, lon});
      const estSpeed = dist / dt;
      if (estSpeed >= HEADING_MIN_SPEED_MPS) {
        headingDeg = bearingDeg({lat:lastFix.lat, lon:lastFix.lon}, {lat, lon});
      }
    }
    lastFix = cur;
  }

  function onPosErr(err) {
    gpsPill.textContent = "GPS: fout";
    gpsPill.style.borderColor = "#553";
    statusEl.textContent = `Locatie fout: ${err.message}`;
  }

  // --------------------------
  // HUD update loop
  // --------------------------
  let uiTimer = null;
  function startUiLoop() {
    if (uiTimer) clearInterval(uiTimer);
    uiTimer = setInterval(updateHud, UPDATE_UI_MS);
  }

  function updateHud() {
    if (!lastFix) {
      arrowWrap.innerHTML = svgArrow("nofix");
      metersEl.textContent = "-- m";
      statusEl.textContent = "Wachten op GPSâ€¦";
      return;
    }
    if (!routePts.length) {
      arrowWrap.innerHTML = svgArrow("nofix");
      metersEl.textContent = "-- m";
      statusEl.textContent = "Route ladenâ€¦";
      return;
    }

    wpIdx = Math.max(0, Math.min(wpIdx, routePts.length - 1));
    const cur = {lat:lastFix.lat, lon:lastFix.lon};
    let target = routePts[wpIdx];
    let d = haversineM(cur, target);

    if (d <= ARRIVE_RADIUS_M && wpIdx < routePts.length - 1) {
      wpIdx++;
      target = routePts[wpIdx];
      d = haversineM(cur, target);
    }

    let arrowType = "up";
    if (headingDeg == null) {
      arrowType = "up";
    } else {
      const b = bearingDeg(cur, target);
      const delta = wrap180(b - headingDeg);
      arrowType = deltaToArrow(delta);
    }
    arrowWrap.innerHTML = svgArrow(arrowType);

    let shown = d;
    if (d > 500) shown = Math.round(d / 10) * 10;
    else if (d > 80) shown = Math.round(d / 5) * 5;
    else shown = Math.round(d);
    metersEl.textContent = `${shown} m`;

    const kmh = Math.max(0, Math.round(speedMps * 3.6));
    statusEl.textContent = `WP ${wpIdx+1}/${routePts.length} | ${kmh} km/h | ${headingDeg==null ? "heading ?" : "heading ok"}`;

    if (debugMapEnabled && map) {
      const ll = [cur.lat, cur.lon];
      if (!posMarker) {
        posMarker = L.circleMarker(ll, {radius:6, color:"#fff", weight:2, fillOpacity:1});
        posMarker.addTo(map);
      } else posMarker.setLatLng(ll);

      if (wpMarker) wpMarker.setLatLng([target.lat, target.lon]);
      map.panTo(ll, {animate:false});
    }
  }

  // --------------------------
  // Map
  // --------------------------
  function ensureMap() {
    if (map) return;
    map = L.map("map", { zoomControl:false });

    L.tileLayer(BW_TILES, { maxZoom: 19 }).addTo(map);
    map.setView([52.0, 5.0], 12);

    setTimeout(() => { try { map.invalidateSize(true); } catch {} }, 120);
  }

  function drawRouteOnMap(points) {
    if (!debugMapEnabled) return;
    ensureMap();

    if (routeLine) routeLine.remove();
    const latlngs = points.map(p => [p.lat, p.lon]);
    routeLine = L.polyline(latlngs, {color:"#fff", weight:3, opacity:0.9});
    routeLine.addTo(map);

    map.fitBounds(routeLine.getBounds(), {padding:[30,30]});

    const tgt = points[Math.min(wpIdx, points.length-1)];
    if (wpMarker) wpMarker.remove();
    wpMarker = L.circleMarker([tgt.lat, tgt.lon], {radius:6, color:"#fff", weight:2, fillOpacity:1});
    wpMarker.addTo(map);

    setTimeout(() => { try { map.invalidateSize(true); } catch {} }, 120);
  }

  // --------------------------
  // UI actions
  // --------------------------
  function showHud() {
    startScreen.classList.remove("active");
    hudScreen.classList.add("active");

    mapPane.style.display = debugMapEnabled ? "block" : "none";
    if (debugMapEnabled) ensureMap();

    applyStageTransform();
    requestFullscreenBestEffort();

    // tap anywhere toggles mirror
    hudScreen.onclick = () => toggleMirror();
  }

  function showStart() {
    hudScreen.classList.remove("active");
    startScreen.classList.add("active");
    hudScreen.onclick = null;
  }

  function toggleMirror() {
    mirrored = !mirrored;
    applyStageTransform();
  }

  function toggleQuarterTurn() {
    quarterTurn = !quarterTurn;
    applyStageTransform();
  }

  function toggleMapPane() {
    debugMapEnabled = !debugMapEnabled;
    debugBtn.textContent = debugMapEnabled ? "Kaart: aan" : "Kaart: uit";
    mapPane.style.display = (hudScreen.classList.contains("active") && debugMapEnabled) ? "block" : "none";
    if (debugMapEnabled) ensureMap();
    applyStageTransform();
  }

  // SpeechRecognition
  function speechSupported() {
    return ("webkitSpeechRecognition" in window) || ("SpeechRecognition" in window);
  }

  function startSpeech() {
    if (!speechSupported()) {
      startStatus.textContent = "Spraak niet ondersteund in deze browser. Typ het adres.";
      return;
    }
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    const rec = new SR();
    rec.lang = "nl-NL";
    rec.interimResults = false;
    rec.maxAlternatives = 1;

    voiceBtn.textContent = "ðŸŽ™ Luisterenâ€¦";
    startStatus.textContent = "Spreek nu het adresâ€¦";

    rec.onresult = (e) => {
      const txt = e.results[0][0].transcript;
      addrInput.value = txt;
      startStatus.textContent = `Herkenning: "${txt}" (pas aan indien nodig)`;
    };
    rec.onerror = (e) => {
      startStatus.textContent = `Spraakfout: ${e.error}. Typ het adres.`;
    };
    rec.onend = () => {
      voiceBtn.textContent = "ðŸŽ™ Spreek adres";
    };
    rec.start();
  }

  async function startNavigation() {
    const q = addrInput.value.trim();
    if (!q) { startStatus.textContent = "Vul of spreek eerst een adres in."; return; }

    startStatus.textContent = "Locatie opvragenâ€¦ (sta toe in je browser)";
    gpsPill.textContent = "GPS: â€¦";

    try {
      startWatch();
      await waitForFix(12000);
      const start = {lat:lastFix.lat, lon:lastFix.lon};

      startStatus.textContent = "Adres zoekenâ€¦";
      const dest = await geocodeAddress(q);

      startStatus.textContent = "Route berekenenâ€¦";
      const rawRoute = await fetchOsrmRoute(start, dest);

      routePts = resampleRoute(rawRoute, LOOKAHEAD_STEP_M);
      wpIdx = 0;

      showHud();
      drawRouteOnMap(routePts);
      startUiLoop();

    } catch (e) {
      startStatus.textContent = `Fout: ${e.message || e}`;
      try { stopWatch(); } catch {}
    }
  }

  function waitForFix(ms) {
    return new Promise((resolve, reject) => {
      const t0 = Date.now();
      const it = setInterval(() => {
        if (lastFix) { clearInterval(it); resolve(true); }
        else if (Date.now() - t0 > ms) { clearInterval(it); reject(new Error("Geen GPS fix ontvangen.")); }
      }, 250);
    });
  }

  function stopAll() {
    stopWatch();
    routePts = [];
    wpIdx = 0;
    headingDeg = null;
    lastFix = null;
    speedMps = 0;
    if (uiTimer) clearInterval(uiTimer);
    uiTimer = null;
    showStart();
    startStatus.textContent = "Gestopt. Je kunt een nieuw adres spreken of typen.";
  }

  // --------------------------
  // Wire up buttons
  // --------------------------
  voiceBtn.addEventListener("click", startSpeech);
  startBtn.addEventListener("click", startNavigation);
  debugBtn.addEventListener("click", toggleMapPane);

  rotToggle.addEventListener("click", (e) => { e.stopPropagation(); toggleQuarterTurn(); });
  mapToggle.addEventListener("click", (e) => { e.stopPropagation(); toggleMapPane(); });
  stopBtn.addEventListener("click", (e) => { e.stopPropagation(); stopAll(); });

  // Long press to stop
  let lpTimer = null;
  hudScreen.addEventListener("touchstart", () => { lpTimer = setTimeout(() => stopAll(), 900); }, {passive:true});
  hudScreen.addEventListener("touchend", () => { if (lpTimer) clearTimeout(lpTimer); lpTimer = null; }, {passive:true});

  startStatus.textContent = speechSupported()
    ? "Tip: Spreek adres. Sta locatie toe. In HUD: tik = spiegeling, â¤¾ = kwartslag, ðŸ—º = kaart."
    : "Spraak niet ondersteund in deze browser. Typ het adres. Sta locatie toe.";

  applyStageTransform();
})();
</script>
</body>
</html>
